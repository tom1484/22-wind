{"ast":null,"code":"import { File } from 'fetch-blob/from.js';\nimport { FormData } from 'formdata-polyfill/esm.min.js';\nlet s = 0;\nconst S = {\n  START_BOUNDARY: s++,\n  HEADER_FIELD_START: s++,\n  HEADER_FIELD: s++,\n  HEADER_VALUE_START: s++,\n  HEADER_VALUE: s++,\n  HEADER_VALUE_ALMOST_DONE: s++,\n  HEADERS_ALMOST_DONE: s++,\n  PART_DATA_START: s++,\n  PART_DATA: s++,\n  END: s++\n};\nlet f = 1;\nconst F = {\n  PART_BOUNDARY: f,\n  LAST_BOUNDARY: f *= 2\n};\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nconst lower = c => c | 0x20;\n\nconst noop = () => {};\n\nclass MultipartParser {\n  /**\n   * @param {string} boundary\n   */\n  constructor(boundary) {\n    this.index = 0;\n    this.flags = 0;\n    this.onHeaderEnd = noop;\n    this.onHeaderField = noop;\n    this.onHeadersEnd = noop;\n    this.onHeaderValue = noop;\n    this.onPartBegin = noop;\n    this.onPartData = noop;\n    this.onPartEnd = noop;\n    this.boundaryChars = {};\n    boundary = '\\r\\n--' + boundary;\n    const ui8a = new Uint8Array(boundary.length);\n\n    for (let i = 0; i < boundary.length; i++) {\n      ui8a[i] = boundary.charCodeAt(i);\n      this.boundaryChars[ui8a[i]] = true;\n    }\n\n    this.boundary = ui8a;\n    this.lookbehind = new Uint8Array(this.boundary.length + 8);\n    this.state = S.START_BOUNDARY;\n  }\n  /**\n   * @param {Uint8Array} data\n   */\n\n\n  write(data) {\n    let i = 0;\n    const length_ = data.length;\n    let previousIndex = this.index;\n    let {\n      lookbehind,\n      boundary,\n      boundaryChars,\n      index,\n      state,\n      flags\n    } = this;\n    const boundaryLength = this.boundary.length;\n    const boundaryEnd = boundaryLength - 1;\n    const bufferLength = data.length;\n    let c;\n    let cl;\n\n    const mark = name => {\n      this[name + 'Mark'] = i;\n    };\n\n    const clear = name => {\n      delete this[name + 'Mark'];\n    };\n\n    const callback = (callbackSymbol, start, end, ui8a) => {\n      if (start === undefined || start !== end) {\n        this[callbackSymbol](ui8a && ui8a.subarray(start, end));\n      }\n    };\n\n    const dataCallback = (name, clear) => {\n      const markSymbol = name + 'Mark';\n\n      if (!(markSymbol in this)) {\n        return;\n      }\n\n      if (clear) {\n        callback(name, this[markSymbol], i, data);\n        delete this[markSymbol];\n      } else {\n        callback(name, this[markSymbol], data.length, data);\n        this[markSymbol] = 0;\n      }\n    };\n\n    for (i = 0; i < length_; i++) {\n      c = data[i];\n\n      switch (state) {\n        case S.START_BOUNDARY:\n          if (index === boundary.length - 2) {\n            if (c === HYPHEN) {\n              flags |= F.LAST_BOUNDARY;\n            } else if (c !== CR) {\n              return;\n            }\n\n            index++;\n            break;\n          } else if (index - 1 === boundary.length - 2) {\n            if (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n              state = S.END;\n              flags = 0;\n            } else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n              index = 0;\n              callback('onPartBegin');\n              state = S.HEADER_FIELD_START;\n            } else {\n              return;\n            }\n\n            break;\n          }\n\n          if (c !== boundary[index + 2]) {\n            index = -2;\n          }\n\n          if (c === boundary[index + 2]) {\n            index++;\n          }\n\n          break;\n\n        case S.HEADER_FIELD_START:\n          state = S.HEADER_FIELD;\n          mark('onHeaderField');\n          index = 0;\n        // falls through\n\n        case S.HEADER_FIELD:\n          if (c === CR) {\n            clear('onHeaderField');\n            state = S.HEADERS_ALMOST_DONE;\n            break;\n          }\n\n          index++;\n\n          if (c === HYPHEN) {\n            break;\n          }\n\n          if (c === COLON) {\n            if (index === 1) {\n              // empty header field\n              return;\n            }\n\n            dataCallback('onHeaderField', true);\n            state = S.HEADER_VALUE_START;\n            break;\n          }\n\n          cl = lower(c);\n\n          if (cl < A || cl > Z) {\n            return;\n          }\n\n          break;\n\n        case S.HEADER_VALUE_START:\n          if (c === SPACE) {\n            break;\n          }\n\n          mark('onHeaderValue');\n          state = S.HEADER_VALUE;\n        // falls through\n\n        case S.HEADER_VALUE:\n          if (c === CR) {\n            dataCallback('onHeaderValue', true);\n            callback('onHeaderEnd');\n            state = S.HEADER_VALUE_ALMOST_DONE;\n          }\n\n          break;\n\n        case S.HEADER_VALUE_ALMOST_DONE:\n          if (c !== LF) {\n            return;\n          }\n\n          state = S.HEADER_FIELD_START;\n          break;\n\n        case S.HEADERS_ALMOST_DONE:\n          if (c !== LF) {\n            return;\n          }\n\n          callback('onHeadersEnd');\n          state = S.PART_DATA_START;\n          break;\n\n        case S.PART_DATA_START:\n          state = S.PART_DATA;\n          mark('onPartData');\n        // falls through\n\n        case S.PART_DATA:\n          previousIndex = index;\n\n          if (index === 0) {\n            // boyer-moore derrived algorithm to safely skip non-boundary data\n            i += boundaryEnd;\n\n            while (i < bufferLength && !(data[i] in boundaryChars)) {\n              i += boundaryLength;\n            }\n\n            i -= boundaryEnd;\n            c = data[i];\n          }\n\n          if (index < boundary.length) {\n            if (boundary[index] === c) {\n              if (index === 0) {\n                dataCallback('onPartData', true);\n              }\n\n              index++;\n            } else {\n              index = 0;\n            }\n          } else if (index === boundary.length) {\n            index++;\n\n            if (c === CR) {\n              // CR = part boundary\n              flags |= F.PART_BOUNDARY;\n            } else if (c === HYPHEN) {\n              // HYPHEN = end boundary\n              flags |= F.LAST_BOUNDARY;\n            } else {\n              index = 0;\n            }\n          } else if (index - 1 === boundary.length) {\n            if (flags & F.PART_BOUNDARY) {\n              index = 0;\n\n              if (c === LF) {\n                // unset the PART_BOUNDARY flag\n                flags &= ~F.PART_BOUNDARY;\n                callback('onPartEnd');\n                callback('onPartBegin');\n                state = S.HEADER_FIELD_START;\n                break;\n              }\n            } else if (flags & F.LAST_BOUNDARY) {\n              if (c === HYPHEN) {\n                callback('onPartEnd');\n                state = S.END;\n                flags = 0;\n              } else {\n                index = 0;\n              }\n            } else {\n              index = 0;\n            }\n          }\n\n          if (index > 0) {\n            // when matching a possible boundary, keep a lookbehind reference\n            // in case it turns out to be a false lead\n            lookbehind[index - 1] = c;\n          } else if (previousIndex > 0) {\n            // if our boundary turned out to be rubbish, the captured lookbehind\n            // belongs to partData\n            const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n\n            callback('onPartData', 0, previousIndex, _lookbehind);\n            previousIndex = 0;\n            mark('onPartData'); // reconsider the current character even so it interrupted the sequence\n            // it could be the beginning of a new sequence\n\n            i--;\n          }\n\n          break;\n\n        case S.END:\n          break;\n\n        default:\n          throw new Error(`Unexpected state entered: ${state}`);\n      }\n    }\n\n    dataCallback('onHeaderField');\n    dataCallback('onHeaderValue');\n    dataCallback('onPartData'); // Update properties for the next call\n\n    this.index = index;\n    this.state = state;\n    this.flags = flags;\n  }\n\n  end() {\n    if (this.state === S.HEADER_FIELD_START && this.index === 0 || this.state === S.PART_DATA && this.index === this.boundary.length) {\n      this.onPartEnd();\n    } else if (this.state !== S.END) {\n      throw new Error('MultipartParser.end(): stream ended unexpectedly');\n    }\n  }\n\n}\n\nfunction _fileName(headerValue) {\n  // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n  const m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n\n  if (!m) {\n    return;\n  }\n\n  const match = m[2] || m[3] || '';\n  let filename = match.slice(match.lastIndexOf('\\\\') + 1);\n  filename = filename.replace(/%22/g, '\"');\n  filename = filename.replace(/&#(\\d{4});/g, (m, code) => {\n    return String.fromCharCode(code);\n  });\n  return filename;\n}\n\nexport async function toFormData(Body, ct) {\n  if (!/multipart/i.test(ct)) {\n    throw new TypeError('Failed to fetch');\n  }\n\n  const m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n  if (!m) {\n    throw new TypeError('no or bad content-type header, no multipart boundary');\n  }\n\n  const parser = new MultipartParser(m[1] || m[2]);\n  let headerField;\n  let headerValue;\n  let entryValue;\n  let entryName;\n  let contentType;\n  let filename;\n  const entryChunks = [];\n  const formData = new FormData();\n\n  const onPartData = ui8a => {\n    entryValue += decoder.decode(ui8a, {\n      stream: true\n    });\n  };\n\n  const appendToFile = ui8a => {\n    entryChunks.push(ui8a);\n  };\n\n  const appendFileToFormData = () => {\n    const file = new File(entryChunks, filename, {\n      type: contentType\n    });\n    formData.append(entryName, file);\n  };\n\n  const appendEntryToFormData = () => {\n    formData.append(entryName, entryValue);\n  };\n\n  const decoder = new TextDecoder('utf-8');\n  decoder.decode();\n\n  parser.onPartBegin = function () {\n    parser.onPartData = onPartData;\n    parser.onPartEnd = appendEntryToFormData;\n    headerField = '';\n    headerValue = '';\n    entryValue = '';\n    entryName = '';\n    contentType = '';\n    filename = null;\n    entryChunks.length = 0;\n  };\n\n  parser.onHeaderField = function (ui8a) {\n    headerField += decoder.decode(ui8a, {\n      stream: true\n    });\n  };\n\n  parser.onHeaderValue = function (ui8a) {\n    headerValue += decoder.decode(ui8a, {\n      stream: true\n    });\n  };\n\n  parser.onHeaderEnd = function () {\n    headerValue += decoder.decode();\n    headerField = headerField.toLowerCase();\n\n    if (headerField === 'content-disposition') {\n      // matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n      const m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n\n      if (m) {\n        entryName = m[2] || m[3] || '';\n      }\n\n      filename = _fileName(headerValue);\n\n      if (filename) {\n        parser.onPartData = appendToFile;\n        parser.onPartEnd = appendFileToFormData;\n      }\n    } else if (headerField === 'content-type') {\n      contentType = headerValue;\n    }\n\n    headerValue = '';\n    headerField = '';\n  };\n\n  for await (const chunk of Body) {\n    parser.write(chunk);\n  }\n\n  parser.end();\n  return formData;\n}","map":{"version":3,"sources":["/home/makerspace/mks_users_home/wind/22-wind/frontend/node_modules/node-fetch/src/utils/multipart-parser.js"],"names":["File","FormData","s","S","START_BOUNDARY","HEADER_FIELD_START","HEADER_FIELD","HEADER_VALUE_START","HEADER_VALUE","HEADER_VALUE_ALMOST_DONE","HEADERS_ALMOST_DONE","PART_DATA_START","PART_DATA","END","f","F","PART_BOUNDARY","LAST_BOUNDARY","LF","CR","SPACE","HYPHEN","COLON","A","Z","lower","c","noop","MultipartParser","constructor","boundary","index","flags","onHeaderEnd","onHeaderField","onHeadersEnd","onHeaderValue","onPartBegin","onPartData","onPartEnd","boundaryChars","ui8a","Uint8Array","length","i","charCodeAt","lookbehind","state","write","data","length_","previousIndex","boundaryLength","boundaryEnd","bufferLength","cl","mark","name","clear","callback","callbackSymbol","start","end","undefined","subarray","dataCallback","markSymbol","_lookbehind","buffer","byteOffset","byteLength","Error","_fileName","headerValue","m","match","filename","slice","lastIndexOf","replace","code","String","fromCharCode","toFormData","Body","ct","test","TypeError","parser","headerField","entryValue","entryName","contentType","entryChunks","formData","decoder","decode","stream","appendToFile","push","appendFileToFormData","file","type","append","appendEntryToFormData","TextDecoder","toLowerCase","chunk"],"mappings":"AAAA,SAAQA,IAAR,QAAmB,oBAAnB;AACA,SAAQC,QAAR,QAAuB,8BAAvB;AAEA,IAAIC,CAAC,GAAG,CAAR;AACA,MAAMC,CAAC,GAAG;AACTC,EAAAA,cAAc,EAAEF,CAAC,EADR;AAETG,EAAAA,kBAAkB,EAAEH,CAAC,EAFZ;AAGTI,EAAAA,YAAY,EAAEJ,CAAC,EAHN;AAITK,EAAAA,kBAAkB,EAAEL,CAAC,EAJZ;AAKTM,EAAAA,YAAY,EAAEN,CAAC,EALN;AAMTO,EAAAA,wBAAwB,EAAEP,CAAC,EANlB;AAOTQ,EAAAA,mBAAmB,EAAER,CAAC,EAPb;AAQTS,EAAAA,eAAe,EAAET,CAAC,EART;AASTU,EAAAA,SAAS,EAAEV,CAAC,EATH;AAUTW,EAAAA,GAAG,EAAEX,CAAC;AAVG,CAAV;AAaA,IAAIY,CAAC,GAAG,CAAR;AACA,MAAMC,CAAC,GAAG;AACTC,EAAAA,aAAa,EAAEF,CADN;AAETG,EAAAA,aAAa,EAAEH,CAAC,IAAI;AAFX,CAAV;AAKA,MAAMI,EAAE,GAAG,EAAX;AACA,MAAMC,EAAE,GAAG,EAAX;AACA,MAAMC,KAAK,GAAG,EAAd;AACA,MAAMC,MAAM,GAAG,EAAf;AACA,MAAMC,KAAK,GAAG,EAAd;AACA,MAAMC,CAAC,GAAG,EAAV;AACA,MAAMC,CAAC,GAAG,GAAV;;AAEA,MAAMC,KAAK,GAAGC,CAAC,IAAIA,CAAC,GAAG,IAAvB;;AAEA,MAAMC,IAAI,GAAG,MAAM,CAAE,CAArB;;AAEA,MAAMC,eAAN,CAAsB;AACrB;AACD;AACA;AACCC,EAAAA,WAAW,CAACC,QAAD,EAAW;AACrB,SAAKC,KAAL,GAAa,CAAb;AACA,SAAKC,KAAL,GAAa,CAAb;AAEA,SAAKC,WAAL,GAAmBN,IAAnB;AACA,SAAKO,aAAL,GAAqBP,IAArB;AACA,SAAKQ,YAAL,GAAoBR,IAApB;AACA,SAAKS,aAAL,GAAqBT,IAArB;AACA,SAAKU,WAAL,GAAmBV,IAAnB;AACA,SAAKW,UAAL,GAAkBX,IAAlB;AACA,SAAKY,SAAL,GAAiBZ,IAAjB;AAEA,SAAKa,aAAL,GAAqB,EAArB;AAEAV,IAAAA,QAAQ,GAAG,WAAWA,QAAtB;AACA,UAAMW,IAAI,GAAG,IAAIC,UAAJ,CAAeZ,QAAQ,CAACa,MAAxB,CAAb;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGd,QAAQ,CAACa,MAA7B,EAAqCC,CAAC,EAAtC,EAA0C;AACzCH,MAAAA,IAAI,CAACG,CAAD,CAAJ,GAAUd,QAAQ,CAACe,UAAT,CAAoBD,CAApB,CAAV;AACA,WAAKJ,aAAL,CAAmBC,IAAI,CAACG,CAAD,CAAvB,IAA8B,IAA9B;AACA;;AAED,SAAKd,QAAL,GAAgBW,IAAhB;AACA,SAAKK,UAAL,GAAkB,IAAIJ,UAAJ,CAAe,KAAKZ,QAAL,CAAca,MAAd,GAAuB,CAAtC,CAAlB;AACA,SAAKI,KAAL,GAAa5C,CAAC,CAACC,cAAf;AACA;AAED;AACD;AACA;;;AACC4C,EAAAA,KAAK,CAACC,IAAD,EAAO;AACX,QAAIL,CAAC,GAAG,CAAR;AACA,UAAMM,OAAO,GAAGD,IAAI,CAACN,MAArB;AACA,QAAIQ,aAAa,GAAG,KAAKpB,KAAzB;AACA,QAAI;AAACe,MAAAA,UAAD;AAAahB,MAAAA,QAAb;AAAuBU,MAAAA,aAAvB;AAAsCT,MAAAA,KAAtC;AAA6CgB,MAAAA,KAA7C;AAAoDf,MAAAA;AAApD,QAA6D,IAAjE;AACA,UAAMoB,cAAc,GAAG,KAAKtB,QAAL,CAAca,MAArC;AACA,UAAMU,WAAW,GAAGD,cAAc,GAAG,CAArC;AACA,UAAME,YAAY,GAAGL,IAAI,CAACN,MAA1B;AACA,QAAIjB,CAAJ;AACA,QAAI6B,EAAJ;;AAEA,UAAMC,IAAI,GAAGC,IAAI,IAAI;AACpB,WAAKA,IAAI,GAAG,MAAZ,IAAsBb,CAAtB;AACA,KAFD;;AAIA,UAAMc,KAAK,GAAGD,IAAI,IAAI;AACrB,aAAO,KAAKA,IAAI,GAAG,MAAZ,CAAP;AACA,KAFD;;AAIA,UAAME,QAAQ,GAAG,CAACC,cAAD,EAAiBC,KAAjB,EAAwBC,GAAxB,EAA6BrB,IAA7B,KAAsC;AACtD,UAAIoB,KAAK,KAAKE,SAAV,IAAuBF,KAAK,KAAKC,GAArC,EAA0C;AACzC,aAAKF,cAAL,EAAqBnB,IAAI,IAAIA,IAAI,CAACuB,QAAL,CAAcH,KAAd,EAAqBC,GAArB,CAA7B;AACA;AACD,KAJD;;AAMA,UAAMG,YAAY,GAAG,CAACR,IAAD,EAAOC,KAAP,KAAiB;AACrC,YAAMQ,UAAU,GAAGT,IAAI,GAAG,MAA1B;;AACA,UAAI,EAAES,UAAU,IAAI,IAAhB,CAAJ,EAA2B;AAC1B;AACA;;AAED,UAAIR,KAAJ,EAAW;AACVC,QAAAA,QAAQ,CAACF,IAAD,EAAO,KAAKS,UAAL,CAAP,EAAyBtB,CAAzB,EAA4BK,IAA5B,CAAR;AACA,eAAO,KAAKiB,UAAL,CAAP;AACA,OAHD,MAGO;AACNP,QAAAA,QAAQ,CAACF,IAAD,EAAO,KAAKS,UAAL,CAAP,EAAyBjB,IAAI,CAACN,MAA9B,EAAsCM,IAAtC,CAAR;AACA,aAAKiB,UAAL,IAAmB,CAAnB;AACA;AACD,KAbD;;AAeA,SAAKtB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGM,OAAhB,EAAyBN,CAAC,EAA1B,EAA8B;AAC7BlB,MAAAA,CAAC,GAAGuB,IAAI,CAACL,CAAD,CAAR;;AAEA,cAAQG,KAAR;AACC,aAAK5C,CAAC,CAACC,cAAP;AACC,cAAI2B,KAAK,KAAKD,QAAQ,CAACa,MAAT,GAAkB,CAAhC,EAAmC;AAClC,gBAAIjB,CAAC,KAAKL,MAAV,EAAkB;AACjBW,cAAAA,KAAK,IAAIjB,CAAC,CAACE,aAAX;AACA,aAFD,MAEO,IAAIS,CAAC,KAAKP,EAAV,EAAc;AACpB;AACA;;AAEDY,YAAAA,KAAK;AACL;AACA,WATD,MASO,IAAIA,KAAK,GAAG,CAAR,KAAcD,QAAQ,CAACa,MAAT,GAAkB,CAApC,EAAuC;AAC7C,gBAAIX,KAAK,GAAGjB,CAAC,CAACE,aAAV,IAA2BS,CAAC,KAAKL,MAArC,EAA6C;AAC5C0B,cAAAA,KAAK,GAAG5C,CAAC,CAACU,GAAV;AACAmB,cAAAA,KAAK,GAAG,CAAR;AACA,aAHD,MAGO,IAAI,EAAEA,KAAK,GAAGjB,CAAC,CAACE,aAAZ,KAA8BS,CAAC,KAAKR,EAAxC,EAA4C;AAClDa,cAAAA,KAAK,GAAG,CAAR;AACA4B,cAAAA,QAAQ,CAAC,aAAD,CAAR;AACAZ,cAAAA,KAAK,GAAG5C,CAAC,CAACE,kBAAV;AACA,aAJM,MAIA;AACN;AACA;;AAED;AACA;;AAED,cAAIqB,CAAC,KAAKI,QAAQ,CAACC,KAAK,GAAG,CAAT,CAAlB,EAA+B;AAC9BA,YAAAA,KAAK,GAAG,CAAC,CAAT;AACA;;AAED,cAAIL,CAAC,KAAKI,QAAQ,CAACC,KAAK,GAAG,CAAT,CAAlB,EAA+B;AAC9BA,YAAAA,KAAK;AACL;;AAED;;AACD,aAAK5B,CAAC,CAACE,kBAAP;AACC0C,UAAAA,KAAK,GAAG5C,CAAC,CAACG,YAAV;AACAkD,UAAAA,IAAI,CAAC,eAAD,CAAJ;AACAzB,UAAAA,KAAK,GAAG,CAAR;AACA;;AACD,aAAK5B,CAAC,CAACG,YAAP;AACC,cAAIoB,CAAC,KAAKP,EAAV,EAAc;AACbuC,YAAAA,KAAK,CAAC,eAAD,CAAL;AACAX,YAAAA,KAAK,GAAG5C,CAAC,CAACO,mBAAV;AACA;AACA;;AAEDqB,UAAAA,KAAK;;AACL,cAAIL,CAAC,KAAKL,MAAV,EAAkB;AACjB;AACA;;AAED,cAAIK,CAAC,KAAKJ,KAAV,EAAiB;AAChB,gBAAIS,KAAK,KAAK,CAAd,EAAiB;AAChB;AACA;AACA;;AAEDkC,YAAAA,YAAY,CAAC,eAAD,EAAkB,IAAlB,CAAZ;AACAlB,YAAAA,KAAK,GAAG5C,CAAC,CAACI,kBAAV;AACA;AACA;;AAEDgD,UAAAA,EAAE,GAAG9B,KAAK,CAACC,CAAD,CAAV;;AACA,cAAI6B,EAAE,GAAGhC,CAAL,IAAUgC,EAAE,GAAG/B,CAAnB,EAAsB;AACrB;AACA;;AAED;;AACD,aAAKrB,CAAC,CAACI,kBAAP;AACC,cAAImB,CAAC,KAAKN,KAAV,EAAiB;AAChB;AACA;;AAEDoC,UAAAA,IAAI,CAAC,eAAD,CAAJ;AACAT,UAAAA,KAAK,GAAG5C,CAAC,CAACK,YAAV;AACA;;AACD,aAAKL,CAAC,CAACK,YAAP;AACC,cAAIkB,CAAC,KAAKP,EAAV,EAAc;AACb8C,YAAAA,YAAY,CAAC,eAAD,EAAkB,IAAlB,CAAZ;AACAN,YAAAA,QAAQ,CAAC,aAAD,CAAR;AACAZ,YAAAA,KAAK,GAAG5C,CAAC,CAACM,wBAAV;AACA;;AAED;;AACD,aAAKN,CAAC,CAACM,wBAAP;AACC,cAAIiB,CAAC,KAAKR,EAAV,EAAc;AACb;AACA;;AAED6B,UAAAA,KAAK,GAAG5C,CAAC,CAACE,kBAAV;AACA;;AACD,aAAKF,CAAC,CAACO,mBAAP;AACC,cAAIgB,CAAC,KAAKR,EAAV,EAAc;AACb;AACA;;AAEDyC,UAAAA,QAAQ,CAAC,cAAD,CAAR;AACAZ,UAAAA,KAAK,GAAG5C,CAAC,CAACQ,eAAV;AACA;;AACD,aAAKR,CAAC,CAACQ,eAAP;AACCoC,UAAAA,KAAK,GAAG5C,CAAC,CAACS,SAAV;AACA4C,UAAAA,IAAI,CAAC,YAAD,CAAJ;AACA;;AACD,aAAKrD,CAAC,CAACS,SAAP;AACCuC,UAAAA,aAAa,GAAGpB,KAAhB;;AAEA,cAAIA,KAAK,KAAK,CAAd,EAAiB;AAChB;AACAa,YAAAA,CAAC,IAAIS,WAAL;;AACA,mBAAOT,CAAC,GAAGU,YAAJ,IAAoB,EAAEL,IAAI,CAACL,CAAD,CAAJ,IAAWJ,aAAb,CAA3B,EAAwD;AACvDI,cAAAA,CAAC,IAAIQ,cAAL;AACA;;AAEDR,YAAAA,CAAC,IAAIS,WAAL;AACA3B,YAAAA,CAAC,GAAGuB,IAAI,CAACL,CAAD,CAAR;AACA;;AAED,cAAIb,KAAK,GAAGD,QAAQ,CAACa,MAArB,EAA6B;AAC5B,gBAAIb,QAAQ,CAACC,KAAD,CAAR,KAAoBL,CAAxB,EAA2B;AAC1B,kBAAIK,KAAK,KAAK,CAAd,EAAiB;AAChBkC,gBAAAA,YAAY,CAAC,YAAD,EAAe,IAAf,CAAZ;AACA;;AAEDlC,cAAAA,KAAK;AACL,aAND,MAMO;AACNA,cAAAA,KAAK,GAAG,CAAR;AACA;AACD,WAVD,MAUO,IAAIA,KAAK,KAAKD,QAAQ,CAACa,MAAvB,EAA+B;AACrCZ,YAAAA,KAAK;;AACL,gBAAIL,CAAC,KAAKP,EAAV,EAAc;AACb;AACAa,cAAAA,KAAK,IAAIjB,CAAC,CAACC,aAAX;AACA,aAHD,MAGO,IAAIU,CAAC,KAAKL,MAAV,EAAkB;AACxB;AACAW,cAAAA,KAAK,IAAIjB,CAAC,CAACE,aAAX;AACA,aAHM,MAGA;AACNc,cAAAA,KAAK,GAAG,CAAR;AACA;AACD,WAXM,MAWA,IAAIA,KAAK,GAAG,CAAR,KAAcD,QAAQ,CAACa,MAA3B,EAAmC;AACzC,gBAAIX,KAAK,GAAGjB,CAAC,CAACC,aAAd,EAA6B;AAC5Be,cAAAA,KAAK,GAAG,CAAR;;AACA,kBAAIL,CAAC,KAAKR,EAAV,EAAc;AACb;AACAc,gBAAAA,KAAK,IAAI,CAACjB,CAAC,CAACC,aAAZ;AACA2C,gBAAAA,QAAQ,CAAC,WAAD,CAAR;AACAA,gBAAAA,QAAQ,CAAC,aAAD,CAAR;AACAZ,gBAAAA,KAAK,GAAG5C,CAAC,CAACE,kBAAV;AACA;AACA;AACD,aAVD,MAUO,IAAI2B,KAAK,GAAGjB,CAAC,CAACE,aAAd,EAA6B;AACnC,kBAAIS,CAAC,KAAKL,MAAV,EAAkB;AACjBsC,gBAAAA,QAAQ,CAAC,WAAD,CAAR;AACAZ,gBAAAA,KAAK,GAAG5C,CAAC,CAACU,GAAV;AACAmB,gBAAAA,KAAK,GAAG,CAAR;AACA,eAJD,MAIO;AACND,gBAAAA,KAAK,GAAG,CAAR;AACA;AACD,aARM,MAQA;AACNA,cAAAA,KAAK,GAAG,CAAR;AACA;AACD;;AAED,cAAIA,KAAK,GAAG,CAAZ,EAAe;AACd;AACA;AACAe,YAAAA,UAAU,CAACf,KAAK,GAAG,CAAT,CAAV,GAAwBL,CAAxB;AACA,WAJD,MAIO,IAAIyB,aAAa,GAAG,CAApB,EAAuB;AAC7B;AACA;AACA,kBAAMgB,WAAW,GAAG,IAAIzB,UAAJ,CAAeI,UAAU,CAACsB,MAA1B,EAAkCtB,UAAU,CAACuB,UAA7C,EAAyDvB,UAAU,CAACwB,UAApE,CAApB;;AACAX,YAAAA,QAAQ,CAAC,YAAD,EAAe,CAAf,EAAkBR,aAAlB,EAAiCgB,WAAjC,CAAR;AACAhB,YAAAA,aAAa,GAAG,CAAhB;AACAK,YAAAA,IAAI,CAAC,YAAD,CAAJ,CAN6B,CAQ7B;AACA;;AACAZ,YAAAA,CAAC;AACD;;AAED;;AACD,aAAKzC,CAAC,CAACU,GAAP;AACC;;AACD;AACC,gBAAM,IAAI0D,KAAJ,CAAW,6BAA4BxB,KAAM,EAA7C,CAAN;AAxLF;AA0LA;;AAEDkB,IAAAA,YAAY,CAAC,eAAD,CAAZ;AACAA,IAAAA,YAAY,CAAC,eAAD,CAAZ;AACAA,IAAAA,YAAY,CAAC,YAAD,CAAZ,CAzOW,CA2OX;;AACA,SAAKlC,KAAL,GAAaA,KAAb;AACA,SAAKgB,KAAL,GAAaA,KAAb;AACA,SAAKf,KAAL,GAAaA,KAAb;AACA;;AAED8B,EAAAA,GAAG,GAAG;AACL,QAAK,KAAKf,KAAL,KAAe5C,CAAC,CAACE,kBAAjB,IAAuC,KAAK0B,KAAL,KAAe,CAAvD,IACF,KAAKgB,KAAL,KAAe5C,CAAC,CAACS,SAAjB,IAA8B,KAAKmB,KAAL,KAAe,KAAKD,QAAL,CAAca,MAD7D,EACsE;AACrE,WAAKJ,SAAL;AACA,KAHD,MAGO,IAAI,KAAKQ,KAAL,KAAe5C,CAAC,CAACU,GAArB,EAA0B;AAChC,YAAM,IAAI0D,KAAJ,CAAU,kDAAV,CAAN;AACA;AACD;;AAzRoB;;AA4RtB,SAASC,SAAT,CAAmBC,WAAnB,EAAgC;AAC/B;AACA,QAAMC,CAAC,GAAGD,WAAW,CAACE,KAAZ,CAAkB,4DAAlB,CAAV;;AACA,MAAI,CAACD,CAAL,EAAQ;AACP;AACA;;AAED,QAAMC,KAAK,GAAGD,CAAC,CAAC,CAAD,CAAD,IAAQA,CAAC,CAAC,CAAD,CAAT,IAAgB,EAA9B;AACA,MAAIE,QAAQ,GAAGD,KAAK,CAACE,KAAN,CAAYF,KAAK,CAACG,WAAN,CAAkB,IAAlB,IAA0B,CAAtC,CAAf;AACAF,EAAAA,QAAQ,GAAGA,QAAQ,CAACG,OAAT,CAAiB,MAAjB,EAAyB,GAAzB,CAAX;AACAH,EAAAA,QAAQ,GAAGA,QAAQ,CAACG,OAAT,CAAiB,aAAjB,EAAgC,CAACL,CAAD,EAAIM,IAAJ,KAAa;AACvD,WAAOC,MAAM,CAACC,YAAP,CAAoBF,IAApB,CAAP;AACA,GAFU,CAAX;AAGA,SAAOJ,QAAP;AACA;;AAED,OAAO,eAAeO,UAAf,CAA0BC,IAA1B,EAAgCC,EAAhC,EAAoC;AAC1C,MAAI,CAAC,aAAaC,IAAb,CAAkBD,EAAlB,CAAL,EAA4B;AAC3B,UAAM,IAAIE,SAAJ,CAAc,iBAAd,CAAN;AACA;;AAED,QAAMb,CAAC,GAAGW,EAAE,CAACV,KAAH,CAAS,iCAAT,CAAV;;AAEA,MAAI,CAACD,CAAL,EAAQ;AACP,UAAM,IAAIa,SAAJ,CAAc,sDAAd,CAAN;AACA;;AAED,QAAMC,MAAM,GAAG,IAAI5D,eAAJ,CAAoB8C,CAAC,CAAC,CAAD,CAAD,IAAQA,CAAC,CAAC,CAAD,CAA7B,CAAf;AAEA,MAAIe,WAAJ;AACA,MAAIhB,WAAJ;AACA,MAAIiB,UAAJ;AACA,MAAIC,SAAJ;AACA,MAAIC,WAAJ;AACA,MAAIhB,QAAJ;AACA,QAAMiB,WAAW,GAAG,EAApB;AACA,QAAMC,QAAQ,GAAG,IAAI7F,QAAJ,EAAjB;;AAEA,QAAMqC,UAAU,GAAGG,IAAI,IAAI;AAC1BiD,IAAAA,UAAU,IAAIK,OAAO,CAACC,MAAR,CAAevD,IAAf,EAAqB;AAACwD,MAAAA,MAAM,EAAE;AAAT,KAArB,CAAd;AACA,GAFD;;AAIA,QAAMC,YAAY,GAAGzD,IAAI,IAAI;AAC5BoD,IAAAA,WAAW,CAACM,IAAZ,CAAiB1D,IAAjB;AACA,GAFD;;AAIA,QAAM2D,oBAAoB,GAAG,MAAM;AAClC,UAAMC,IAAI,GAAG,IAAIrG,IAAJ,CAAS6F,WAAT,EAAsBjB,QAAtB,EAAgC;AAAC0B,MAAAA,IAAI,EAAEV;AAAP,KAAhC,CAAb;AACAE,IAAAA,QAAQ,CAACS,MAAT,CAAgBZ,SAAhB,EAA2BU,IAA3B;AACA,GAHD;;AAKA,QAAMG,qBAAqB,GAAG,MAAM;AACnCV,IAAAA,QAAQ,CAACS,MAAT,CAAgBZ,SAAhB,EAA2BD,UAA3B;AACA,GAFD;;AAIA,QAAMK,OAAO,GAAG,IAAIU,WAAJ,CAAgB,OAAhB,CAAhB;AACAV,EAAAA,OAAO,CAACC,MAAR;;AAEAR,EAAAA,MAAM,CAACnD,WAAP,GAAqB,YAAY;AAChCmD,IAAAA,MAAM,CAAClD,UAAP,GAAoBA,UAApB;AACAkD,IAAAA,MAAM,CAACjD,SAAP,GAAmBiE,qBAAnB;AAEAf,IAAAA,WAAW,GAAG,EAAd;AACAhB,IAAAA,WAAW,GAAG,EAAd;AACAiB,IAAAA,UAAU,GAAG,EAAb;AACAC,IAAAA,SAAS,GAAG,EAAZ;AACAC,IAAAA,WAAW,GAAG,EAAd;AACAhB,IAAAA,QAAQ,GAAG,IAAX;AACAiB,IAAAA,WAAW,CAAClD,MAAZ,GAAqB,CAArB;AACA,GAXD;;AAaA6C,EAAAA,MAAM,CAACtD,aAAP,GAAuB,UAAUO,IAAV,EAAgB;AACtCgD,IAAAA,WAAW,IAAIM,OAAO,CAACC,MAAR,CAAevD,IAAf,EAAqB;AAACwD,MAAAA,MAAM,EAAE;AAAT,KAArB,CAAf;AACA,GAFD;;AAIAT,EAAAA,MAAM,CAACpD,aAAP,GAAuB,UAAUK,IAAV,EAAgB;AACtCgC,IAAAA,WAAW,IAAIsB,OAAO,CAACC,MAAR,CAAevD,IAAf,EAAqB;AAACwD,MAAAA,MAAM,EAAE;AAAT,KAArB,CAAf;AACA,GAFD;;AAIAT,EAAAA,MAAM,CAACvD,WAAP,GAAqB,YAAY;AAChCwC,IAAAA,WAAW,IAAIsB,OAAO,CAACC,MAAR,EAAf;AACAP,IAAAA,WAAW,GAAGA,WAAW,CAACiB,WAAZ,EAAd;;AAEA,QAAIjB,WAAW,KAAK,qBAApB,EAA2C;AAC1C;AACA,YAAMf,CAAC,GAAGD,WAAW,CAACE,KAAZ,CAAkB,mDAAlB,CAAV;;AAEA,UAAID,CAAJ,EAAO;AACNiB,QAAAA,SAAS,GAAGjB,CAAC,CAAC,CAAD,CAAD,IAAQA,CAAC,CAAC,CAAD,CAAT,IAAgB,EAA5B;AACA;;AAEDE,MAAAA,QAAQ,GAAGJ,SAAS,CAACC,WAAD,CAApB;;AAEA,UAAIG,QAAJ,EAAc;AACbY,QAAAA,MAAM,CAAClD,UAAP,GAAoB4D,YAApB;AACAV,QAAAA,MAAM,CAACjD,SAAP,GAAmB6D,oBAAnB;AACA;AACD,KAdD,MAcO,IAAIX,WAAW,KAAK,cAApB,EAAoC;AAC1CG,MAAAA,WAAW,GAAGnB,WAAd;AACA;;AAEDA,IAAAA,WAAW,GAAG,EAAd;AACAgB,IAAAA,WAAW,GAAG,EAAd;AACA,GAxBD;;AA0BA,aAAW,MAAMkB,KAAjB,IAA0BvB,IAA1B,EAAgC;AAC/BI,IAAAA,MAAM,CAACxC,KAAP,CAAa2D,KAAb;AACA;;AAEDnB,EAAAA,MAAM,CAAC1B,GAAP;AAEA,SAAOgC,QAAP;AACA","sourcesContent":["import {File} from 'fetch-blob/from.js';\nimport {FormData} from 'formdata-polyfill/esm.min.js';\n\nlet s = 0;\nconst S = {\n\tSTART_BOUNDARY: s++,\n\tHEADER_FIELD_START: s++,\n\tHEADER_FIELD: s++,\n\tHEADER_VALUE_START: s++,\n\tHEADER_VALUE: s++,\n\tHEADER_VALUE_ALMOST_DONE: s++,\n\tHEADERS_ALMOST_DONE: s++,\n\tPART_DATA_START: s++,\n\tPART_DATA: s++,\n\tEND: s++\n};\n\nlet f = 1;\nconst F = {\n\tPART_BOUNDARY: f,\n\tLAST_BOUNDARY: f *= 2\n};\n\nconst LF = 10;\nconst CR = 13;\nconst SPACE = 32;\nconst HYPHEN = 45;\nconst COLON = 58;\nconst A = 97;\nconst Z = 122;\n\nconst lower = c => c | 0x20;\n\nconst noop = () => {};\n\nclass MultipartParser {\n\t/**\n\t * @param {string} boundary\n\t */\n\tconstructor(boundary) {\n\t\tthis.index = 0;\n\t\tthis.flags = 0;\n\n\t\tthis.onHeaderEnd = noop;\n\t\tthis.onHeaderField = noop;\n\t\tthis.onHeadersEnd = noop;\n\t\tthis.onHeaderValue = noop;\n\t\tthis.onPartBegin = noop;\n\t\tthis.onPartData = noop;\n\t\tthis.onPartEnd = noop;\n\n\t\tthis.boundaryChars = {};\n\n\t\tboundary = '\\r\\n--' + boundary;\n\t\tconst ui8a = new Uint8Array(boundary.length);\n\t\tfor (let i = 0; i < boundary.length; i++) {\n\t\t\tui8a[i] = boundary.charCodeAt(i);\n\t\t\tthis.boundaryChars[ui8a[i]] = true;\n\t\t}\n\n\t\tthis.boundary = ui8a;\n\t\tthis.lookbehind = new Uint8Array(this.boundary.length + 8);\n\t\tthis.state = S.START_BOUNDARY;\n\t}\n\n\t/**\n\t * @param {Uint8Array} data\n\t */\n\twrite(data) {\n\t\tlet i = 0;\n\t\tconst length_ = data.length;\n\t\tlet previousIndex = this.index;\n\t\tlet {lookbehind, boundary, boundaryChars, index, state, flags} = this;\n\t\tconst boundaryLength = this.boundary.length;\n\t\tconst boundaryEnd = boundaryLength - 1;\n\t\tconst bufferLength = data.length;\n\t\tlet c;\n\t\tlet cl;\n\n\t\tconst mark = name => {\n\t\t\tthis[name + 'Mark'] = i;\n\t\t};\n\n\t\tconst clear = name => {\n\t\t\tdelete this[name + 'Mark'];\n\t\t};\n\n\t\tconst callback = (callbackSymbol, start, end, ui8a) => {\n\t\t\tif (start === undefined || start !== end) {\n\t\t\t\tthis[callbackSymbol](ui8a && ui8a.subarray(start, end));\n\t\t\t}\n\t\t};\n\n\t\tconst dataCallback = (name, clear) => {\n\t\t\tconst markSymbol = name + 'Mark';\n\t\t\tif (!(markSymbol in this)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (clear) {\n\t\t\t\tcallback(name, this[markSymbol], i, data);\n\t\t\t\tdelete this[markSymbol];\n\t\t\t} else {\n\t\t\t\tcallback(name, this[markSymbol], data.length, data);\n\t\t\t\tthis[markSymbol] = 0;\n\t\t\t}\n\t\t};\n\n\t\tfor (i = 0; i < length_; i++) {\n\t\t\tc = data[i];\n\n\t\t\tswitch (state) {\n\t\t\t\tcase S.START_BOUNDARY:\n\t\t\t\t\tif (index === boundary.length - 2) {\n\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else if (c !== CR) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (index - 1 === boundary.length - 2) {\n\t\t\t\t\t\tif (flags & F.LAST_BOUNDARY && c === HYPHEN) {\n\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t} else if (!(flags & F.LAST_BOUNDARY) && c === LF) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c !== boundary[index + 2]) {\n\t\t\t\t\t\tindex = -2;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === boundary[index + 2]) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_FIELD_START:\n\t\t\t\t\tstate = S.HEADER_FIELD;\n\t\t\t\t\tmark('onHeaderField');\n\t\t\t\t\tindex = 0;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_FIELD:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tclear('onHeaderField');\n\t\t\t\t\t\tstate = S.HEADERS_ALMOST_DONE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (c === COLON) {\n\t\t\t\t\t\tif (index === 1) {\n\t\t\t\t\t\t\t// empty header field\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tdataCallback('onHeaderField', true);\n\t\t\t\t\t\tstate = S.HEADER_VALUE_START;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcl = lower(c);\n\t\t\t\t\tif (cl < A || cl > Z) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_START:\n\t\t\t\t\tif (c === SPACE) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tmark('onHeaderValue');\n\t\t\t\t\tstate = S.HEADER_VALUE;\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.HEADER_VALUE:\n\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\tdataCallback('onHeaderValue', true);\n\t\t\t\t\t\tcallback('onHeaderEnd');\n\t\t\t\t\t\tstate = S.HEADER_VALUE_ALMOST_DONE;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADER_VALUE_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.HEADERS_ALMOST_DONE:\n\t\t\t\t\tif (c !== LF) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tcallback('onHeadersEnd');\n\t\t\t\t\tstate = S.PART_DATA_START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.PART_DATA_START:\n\t\t\t\t\tstate = S.PART_DATA;\n\t\t\t\t\tmark('onPartData');\n\t\t\t\t\t// falls through\n\t\t\t\tcase S.PART_DATA:\n\t\t\t\t\tpreviousIndex = index;\n\n\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t// boyer-moore derrived algorithm to safely skip non-boundary data\n\t\t\t\t\t\ti += boundaryEnd;\n\t\t\t\t\t\twhile (i < bufferLength && !(data[i] in boundaryChars)) {\n\t\t\t\t\t\t\ti += boundaryLength;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ti -= boundaryEnd;\n\t\t\t\t\t\tc = data[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index < boundary.length) {\n\t\t\t\t\t\tif (boundary[index] === c) {\n\t\t\t\t\t\t\tif (index === 0) {\n\t\t\t\t\t\t\t\tdataCallback('onPartData', true);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index === boundary.length) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif (c === CR) {\n\t\t\t\t\t\t\t// CR = part boundary\n\t\t\t\t\t\t\tflags |= F.PART_BOUNDARY;\n\t\t\t\t\t\t} else if (c === HYPHEN) {\n\t\t\t\t\t\t\t// HYPHEN = end boundary\n\t\t\t\t\t\t\tflags |= F.LAST_BOUNDARY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (index - 1 === boundary.length) {\n\t\t\t\t\t\tif (flags & F.PART_BOUNDARY) {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\tif (c === LF) {\n\t\t\t\t\t\t\t\t// unset the PART_BOUNDARY flag\n\t\t\t\t\t\t\t\tflags &= ~F.PART_BOUNDARY;\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tcallback('onPartBegin');\n\t\t\t\t\t\t\t\tstate = S.HEADER_FIELD_START;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (flags & F.LAST_BOUNDARY) {\n\t\t\t\t\t\t\tif (c === HYPHEN) {\n\t\t\t\t\t\t\t\tcallback('onPartEnd');\n\t\t\t\t\t\t\t\tstate = S.END;\n\t\t\t\t\t\t\t\tflags = 0;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\t// when matching a possible boundary, keep a lookbehind reference\n\t\t\t\t\t\t// in case it turns out to be a false lead\n\t\t\t\t\t\tlookbehind[index - 1] = c;\n\t\t\t\t\t} else if (previousIndex > 0) {\n\t\t\t\t\t\t// if our boundary turned out to be rubbish, the captured lookbehind\n\t\t\t\t\t\t// belongs to partData\n\t\t\t\t\t\tconst _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);\n\t\t\t\t\t\tcallback('onPartData', 0, previousIndex, _lookbehind);\n\t\t\t\t\t\tpreviousIndex = 0;\n\t\t\t\t\t\tmark('onPartData');\n\n\t\t\t\t\t\t// reconsider the current character even so it interrupted the sequence\n\t\t\t\t\t\t// it could be the beginning of a new sequence\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\tcase S.END:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Unexpected state entered: ${state}`);\n\t\t\t}\n\t\t}\n\n\t\tdataCallback('onHeaderField');\n\t\tdataCallback('onHeaderValue');\n\t\tdataCallback('onPartData');\n\n\t\t// Update properties for the next call\n\t\tthis.index = index;\n\t\tthis.state = state;\n\t\tthis.flags = flags;\n\t}\n\n\tend() {\n\t\tif ((this.state === S.HEADER_FIELD_START && this.index === 0) ||\n\t\t\t(this.state === S.PART_DATA && this.index === this.boundary.length)) {\n\t\t\tthis.onPartEnd();\n\t\t} else if (this.state !== S.END) {\n\t\t\tthrow new Error('MultipartParser.end(): stream ended unexpectedly');\n\t\t}\n\t}\n}\n\nfunction _fileName(headerValue) {\n\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\tconst m = headerValue.match(/\\bfilename=(\"(.*?)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))($|;\\s)/i);\n\tif (!m) {\n\t\treturn;\n\t}\n\n\tconst match = m[2] || m[3] || '';\n\tlet filename = match.slice(match.lastIndexOf('\\\\') + 1);\n\tfilename = filename.replace(/%22/g, '\"');\n\tfilename = filename.replace(/&#(\\d{4});/g, (m, code) => {\n\t\treturn String.fromCharCode(code);\n\t});\n\treturn filename;\n}\n\nexport async function toFormData(Body, ct) {\n\tif (!/multipart/i.test(ct)) {\n\t\tthrow new TypeError('Failed to fetch');\n\t}\n\n\tconst m = ct.match(/boundary=(?:\"([^\"]+)\"|([^;]+))/i);\n\n\tif (!m) {\n\t\tthrow new TypeError('no or bad content-type header, no multipart boundary');\n\t}\n\n\tconst parser = new MultipartParser(m[1] || m[2]);\n\n\tlet headerField;\n\tlet headerValue;\n\tlet entryValue;\n\tlet entryName;\n\tlet contentType;\n\tlet filename;\n\tconst entryChunks = [];\n\tconst formData = new FormData();\n\n\tconst onPartData = ui8a => {\n\t\tentryValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tconst appendToFile = ui8a => {\n\t\tentryChunks.push(ui8a);\n\t};\n\n\tconst appendFileToFormData = () => {\n\t\tconst file = new File(entryChunks, filename, {type: contentType});\n\t\tformData.append(entryName, file);\n\t};\n\n\tconst appendEntryToFormData = () => {\n\t\tformData.append(entryName, entryValue);\n\t};\n\n\tconst decoder = new TextDecoder('utf-8');\n\tdecoder.decode();\n\n\tparser.onPartBegin = function () {\n\t\tparser.onPartData = onPartData;\n\t\tparser.onPartEnd = appendEntryToFormData;\n\n\t\theaderField = '';\n\t\theaderValue = '';\n\t\tentryValue = '';\n\t\tentryName = '';\n\t\tcontentType = '';\n\t\tfilename = null;\n\t\tentryChunks.length = 0;\n\t};\n\n\tparser.onHeaderField = function (ui8a) {\n\t\theaderField += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderValue = function (ui8a) {\n\t\theaderValue += decoder.decode(ui8a, {stream: true});\n\t};\n\n\tparser.onHeaderEnd = function () {\n\t\theaderValue += decoder.decode();\n\t\theaderField = headerField.toLowerCase();\n\n\t\tif (headerField === 'content-disposition') {\n\t\t\t// matches either a quoted-string or a token (RFC 2616 section 19.5.1)\n\t\t\tconst m = headerValue.match(/\\bname=(\"([^\"]*)\"|([^()<>@,;:\\\\\"/[\\]?={}\\s\\t]+))/i);\n\n\t\t\tif (m) {\n\t\t\t\tentryName = m[2] || m[3] || '';\n\t\t\t}\n\n\t\t\tfilename = _fileName(headerValue);\n\n\t\t\tif (filename) {\n\t\t\t\tparser.onPartData = appendToFile;\n\t\t\t\tparser.onPartEnd = appendFileToFormData;\n\t\t\t}\n\t\t} else if (headerField === 'content-type') {\n\t\t\tcontentType = headerValue;\n\t\t}\n\n\t\theaderValue = '';\n\t\theaderField = '';\n\t};\n\n\tfor await (const chunk of Body) {\n\t\tparser.write(chunk);\n\t}\n\n\tparser.end();\n\n\treturn formData;\n}\n"]},"metadata":{},"sourceType":"module"}